make 명령어를 수행해서 gcc를 한 후에
./20171669.out 명령어로 프로그램을 수행시킵니다.

실행되는 명령어의 종류로는
h[elp],d[ir],du[mp] [start address] [, end address],e[dit] address, value
hi[story], f[ill] start address, end address, value
reset, opcodelist, opcode mneonic(명령어), q[uit]
type filename, symbol, assemble filename 이 존재한다.
명령어는 최대 100자리까지 입력이 가능하다.

각각의 명령어들은 탭과 띄어쓰기가 있어도 명령어로 읽히며
수행한 명령어들은 linked list의 방식으로 저장되어서
hi[story]명령어를 수행하면 그동안 입력한 명령어들을 볼 수 있습니다.
물론 기능을 하지 않은 잘못된 명령어들은 저장되지 않습니다.
이때, 탭과 띄어쓰기 혹은 16진수로 주소나 값을 입력할 때 linked list에는
정석적인 명령어의 형태로 저장됩니다.
(16진수의 경우 소문자로 입력 된 것들은 대문자로 저장됩니다.)

--------------------proj2 추가 내용-------------------------------------
++type 명령어의 경우에는 디렉토리에 type 뒤의 파일명의 파일이 있다면 그 파일
안에 있는 내용을 출력해준다. 없다면 에러문구가 출력된다.
++assemble 명령어의 경우에는 디렉토리에 .asm 파일이 존재할 경우 어셈블을 
시작하는데 이때, 파일이 없거나 .asm파일이 아닌 경우에는 에러문구를 출력한다.
또한 assemble 명령어가 수행되면 pass1과 pass2함수가 실행되는데 이 과정에서
오류가 발생하면 그 .asm파일의 몇번째 라인에서 오류가 발생했는지 출력된다.
++symbol 명령어의 경우 어셈블 한 것이 없어 비어있을 떄는 symbol table이
비었다고 문구가 출력되고 history에는 정상적으로 들어간다.
어셈블이 제대로 된 경우에는 가장 최근에 어셈블한 파일의 symbol table이
오름차순으로 정렬이 된다.
------------------------------------------------------------------------
--------------------proj3 추가 내용-------------------------------------
++loader 명령어의 경우에는 디렉토리에 .obj파일이 존재할 경우 loader을
pass1, pass2를 연달아 수행하는데 이 때, .obj파일이 아니라면 오류 문구를
출력한다.
++progaddr 명령어의 경우에는 program의 주소를 progaddr 명령어 뒤에 있는
값을 program의 주소 progaddr 변수에 저장한다.
++bp 명령어의 경우에는 Breakpoint를 설정하는 명령어인데 bp명령어 뒤에
breakpoint 위치가 나온다면 mem_bp[breakpoint]에서 0에서 값을 바꾼다. 그냥
bp가 들어온 경우 bp가 설정되어 있는 위치의 breakpoint들을 출력한다. bp
clear 명령어의 경우에는 0이 아닌 값들을 모두 다시 0으로 초기화하는 기능을
한다.
++run명령어의 경우 load를 통해 메모리에 object file들이 올라가고
progaddr에 따라서 그 값부터 bp가 설정된 곳까지 run을 수행하고 bp가 없다면
프로그램의 끝까지 간 후 run 함수를 종료한다.
------------------------------------------------------------------------

프로그램의 종료는 명령어 q[uit]을 통해서만 가능합니다.

