make 명령어를 수행해서 gcc를 한 후에
./20171669.out 명령어로 프로그램을 수행시킵니다.

실행되는 명령어의 종류로는
h[elp],d[ir],du[mp] [start address] [, end address],e[dit] address, value
hi[story], f[ill] start address, end address, value
reset, opcodelist, opcode mneonic(명령어), q[uit]
type filename, symbol, assemble filename 이 존재한다.
명령어는 최대 100자리까지 입력이 가능하다.

각각의 명령어들은 탭과 띄어쓰기가 있어도 명령어로 읽히며
수행한 명령어들은 linked list의 방식으로 저장되어서
hi[story]명령어를 수행하면 그동안 입력한 명령어들을 볼 수 있습니다.
물론 기능을 하지 않은 잘못된 명령어들은 저장되지 않습니다.
이때, 탭과 띄어쓰기 혹은 16진수로 주소나 값을 입력할 때 linked list에는
정석적인 명령어의 형태로 저장됩니다.
(16진수의 경우 소문자로 입력 된 것들은 대문자로 저장됩니다.)

--------------------proj2 추가 내용-------------------------------------
++type 명령어의 경우에는 디렉토리에 type 뒤의 파일명의 파일이 있다면 그 파일
안에 있는 내용을 출력해준다. 없다면 에러문구가 출력된다.
++assemble 명령어의 경우에는 디렉토리에 .asm 파일이 존재할 경우 어셈블을 
시작하는데 이때, 파일이 없거나 .asm파일이 아닌 경우에는 에러문구를 출력한다.
또한 assemble 명령어가 수행되면 pass1과 pass2함수가 실행되는데 이 과정에서
오류가 발생하면 그 .asm파일의 몇번째 라인에서 오류가 발생했는지 출력된다.
++symbol 명령어의 경우 어셈블 한 것이 없어 비어있을 떄는 symbol table이
비었다고 문구가 출력되고 history에는 정상적으로 들어간다.
어셈블이 제대로 된 경우에는 가장 최근에 어셈블한 파일의 symbol table이
오름차순으로 정렬이 된다.
------------------------------------------------------------------------

프로그램의 종료는 명령어 q[uit]을 통해서만 가능합니다.

